#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

typedef int цч32;
typedef unsigned char нпбайт;
typedef uint8_t цч8;

struct Угадайка {
    цч32 заряд;
    цч32 сила;
    цч32 предыдущий_бит;
};

цч32 Угадайка(struct Угадайка *п, цч32 текущий_бит) {
    цч32 ПОЛОВИНА_ТОЧНОСТИ = 512;
    цч32 ТОЧНОСТЬ = 1024;
    цч32 МИНИМАЛЬНАЯ_СИЛА = 8;

    цч32 цель = текущий_бит ? 127 : -128;

    цч32 следующий_заряд = п->заряд + floor((п->сила * (цель - п->заряд) + ПОЛОВИНА_ТОЧНОСТИ) / ТОЧНОСТЬ);
    if (следующий_заряд == п->заряд && следующий_заряд != цель) {
        следующий_заряд += текущий_бит ? 1 : -1;
    }

    цч32 следующая_сила = п->сила + (текущий_бит == п->предыдущий_бит ? 1 : -1);
    if (следующая_сила < МИНИМАЛЬНАЯ_СИЛА) следующая_сила = МИНИМАЛЬНАЯ_СИЛА;

    п->заряд = следующий_заряд;
    п->сила = следующая_сила;
    п->предыдущий_бит = текущий_бит;

    return п->заряд;
}


нпбайт Кодер(цч32 вход[8], struct Угадайка *угадайка) {
    цч32 предыдущий_заряд = 0;
    нпбайт байт_выхода = 0;

    for (цч32 j = 0; j < 8; j++) {
        цч32 входной_заряд = вход[j];

        if (входной_заряд > 127 || входной_заряд < -128) {
            printf("Ошибка: значение %d выходит за границы!\n", входной_заряд);
            return 0;
        }

        цч32 текущий_бит = входной_заряд > предыдущий_заряд || (входной_заряд == предыдущий_заряд && входной_заряд == 127);
        байт_выхода = (байт_выхода >> 1) | (текущий_бит ? 128 : 0);

        предыдущий_заряд = Угадайка(угадайка, текущий_бит);
    }

    return байт_выхода;
}

void обработать_вэйв_файл(const char *имя_файла_вход) {
    FILE *файл_вэйв = fopen(имя_файла_вход, "rb");
    if (!файл_вэйв) {
        printf("Ошибка: не удалось открыть файл %s\n", имя_файла_вход);
        return;
    }

    цч8 заголовок[44];
    fread(заголовок, 1, 44, файл_вэйв);

    printf("Тип файла: %.4s\n", заголовок);
    printf("Количество каналов: %d\n", заголовок[22]);
    printf("Битность: %d\n", заголовок[34]);
    printf("Частота дискретизации: %d Гц\n", *(цч32 *)&заголовок[24]);

    if (strncmp((char *)заголовок, "RIFF", 4) != 0 || заголовок[22] != 2 || заголовок[34] != 8 || *(цч32 *)&заголовок[24] != 48000) {
        printf("Ошибка: неверный формат файла!\n");
        printf("Ожидалось: Стерео (2 канала), 8 бит, 48000 Гц.\n");
        fclose(файл_вэйв);
        return;
    }

    char имя_файла_выход[256];
    strncpy(имя_файла_выход, имя_файла_вход, strlen(имя_файла_вход) - 4);
    strcat(имя_файла_выход, ".mdz");

    FILE *файл_mdz = fopen(имя_файла_выход, "wb");
    if (!файл_mdz) {
        printf("Ошибка: не удалось создать файл %s\n", имя_файла_выход);
        fclose(файл_вэйв);
        return;
    }

    struct Угадайка угадайка_левый = {0, 0, 0};
    struct Угадайка угадайка_правый = {0, 0, 0};

    цч8 буфер_сэмплов[16];
    цч32 левый_сэмплы[8], правый_сэмплы[8];

    fseek(файл_вэйв, 0, SEEK_END);
    long размер = ftell(файл_вэйв) - 44;
    fseek(файл_вэйв, 44, SEEK_SET);
    long обработано = 0;

    while (fread(буфер_сэмплов, 1, 16, файл_вэйв) == 16) {
        for (цч32 i = 0; i < 8; i++) {
            левый_сэмплы[i] = буфер_сэмплов[i * 2] - 128;
            правый_сэмплы[i] = буфер_сэмплов[i * 2 + 1] - 128;
        }

        нпбайт закодированный_левый = Кодер(левый_сэмплы, &угадайка_левый);
        нпбайт закодированный_правый = Кодер(правый_сэмплы, &угадайка_правый);

        fputc(закодированный_левый, файл_mdz);
        fputc(закодированный_правый, файл_mdz);

        обработано += 16;
        printf("\rПрогресс: %.2f%%", (обработано / (float)размер) * 100);
        fflush(stdout);
    }

    fclose(файл_вэйв);
    fclose(файл_mdz);
    printf("\nФайл %s успешно создан!\n", имя_файла_выход);
}

цч32 main(цч32 количество_аргументов, char *аргументы[]) {
    if (количество_аргументов < 2) {
        printf("Использование: %s входной_файл.wav\n", аргументы[0]);
        return 1;
    }

    обработать_вэйв_файл(аргументы[1]);
    return 0;
}
